const mongoose = require('mongoose');
require('dotenv').config();

//TELEGRAM BOT
const TelegramBot = require('node-telegram-bot-api');
const token = process.env.TGTOKEN;
const bot = new TelegramBot(token, { polling: true });
const admins = String(process.env.ADMINS).split(',');

const Request = mongoose.model('Request');
const Image = mongoose.model('Image');
const Video = mongoose.model('Video');
const TelegramUser = mongoose.model('TelegramUser');
const Data = mongoose.model('Data');

//BUTTONS TEXT
const CheckContentText = "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∫–æ–Ω—Ç–µ–Ω—Ç"
const SubscribtionText = "üî• –ê–∫—Ç—É–∞–ª—å–Ω—ñ —Ñ–µ–π–∫–∏"
//OTHER TEXT
const FakeNewsText = "–ù–∞–¥—Å–∏–ª–∞—î–º–æ —Ç–æ–±—ñ –ø—ñ–¥–±—ñ—Ä–∫—É —Ñ–µ–π–∫—ñ–≤, —è–∫—ñ –∑–∞—Ä–∞–∑ –ª—ñ—Ç–∞—é—Ç—å –ø–æ –£–∫—Ä–∞—ó–Ω—ñ —Ç–∞ —Å–≤—ñ—Ç—É —ñ –∑–∞–≥—Ä–æ–∂—É—é—Ç—å –Ω–∞–º. –ó–Ω–∞–π –Ω–∞–π–≥–æ–ª–æ–≤–Ω—ñ—à–µ, –ø–æ—à–∏—Ä—é–π —Ü–µ –≤ —Å–æ—Ü—ñ–∞–ª—å–Ω–∏—Ö –º–µ—Ä–µ–∂–∞—Ö —Ç–∞ –ø—Ä–æ—Ç–∏–¥—ñ–π.\n\n";

bot.on('message', async (msg) => {
    const text = msg.text;

    if (text == '/start') {
        let replyOptions = {
            reply_markup: {
                resize_keyboard: true,
                one_time_keyboard: false,
                keyboard: [
                    [{ text: CheckContentText }],
                    [{ text: SubscribtionText }]
                ]
            }
        };

        bot.sendMessage(msg.chat.id, '–ü–µ—Ä–µ–≤—ñ—Ä - —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ–π–Ω–∏–π –±–æ—Ç –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –¥–∞–Ω–∏—Ö —Ç–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —Å—É–º–Ω—ñ–≤–Ω–∏—Ö –Ω–æ–≤–∏–Ω.\n\n–ü–æ–≤—ñ–¥–æ–º–ª—è–π –¥–∞–Ω—ñ, —è–∫—ñ —Ö–æ—á–µ—à –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏:\n-–ø–æ—Å—Ç–∏ –≤ —Å–æ—Ü—ñ–∞–ª—å–Ω–∏—Ö –º–µ—Ä–µ–∂–∞—Ö\n-–ø–æ—Å–∏–ª–∞–Ω–Ω—è\n-–º–µ–¥—ñ–∞—Ñ–∞–π–ª–∏ –∞–±–æ —Ñ–æ—Ç–æ\n\n–¶–µ–π –∫–æ–Ω—Ç–µ–Ω—Ç –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç—å—Å—è –≤—Ä—É—á–Ω—É —Ç–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º–∏ —ñ –º–∏ –¥–∞–º–æ —Ç–æ–±—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—å.\n\n–ü–µ—Ä–µ–≤—ñ—Ä—è—é—Ç—å —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –∂—É—Ä–Ω–∞–ª—ñ—Å—Ç–∏ @gwaramedia, –º–µ–¥—ñ–∞–≤–æ–ª–æ–Ω—Ç–µ—Ä–∏ —Ç–∞ –≥—Ä–æ–º–∞–¥—Å—å–∫—ñ –∞–∫—Ç–∏–≤—ñ—Å—Ç–∏.', replyOptions);
        //Check if user registerd
        var newUser = new TelegramUser({
            _id: new mongoose.Types.ObjectId(),
            telegramID: msg.chat.id
        });
        newUser.save().then(() => {}).catch((error) => {
            console.log("MongoErr: " + error.code);
        });


    } else if (text == CheckContentText) {
        bot.sendMessage(msg.chat.id, '–ù–∞–¥—ñ—à–ª—ñ—Ç—å —á–∏ –ø–µ—Ä–µ—à–ª—ñ—Ç—å –º–∞—Ç–µ—Ä—ñ–∞–ª–∏ —è–∫—ñ –±–∞–∂–∞—î—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏');

    } else if (text == SubscribtionText) {
        const user = await TelegramUser.findOne({telegramID: msg.chat.id});
        if (!user) return console.log("User not found 1.1")
        const inline_keyboard = getSubscriptionBtn(user.subscribed, user._id);
        var options = {
            parse_mode: 'HTML',
            reply_markup: JSON.stringify({
                inline_keyboard
            }) 
        };
        const fakeNews = await Data.findOne({name: 'fakeNews'});
        try {
            bot.sendMessage(msg.chat.id, FakeNewsText + fakeNews.value, options);
        } catch (e) { console.log(e) }

    } else if (text.indexOf('/setfakes ') != -1) {
        if (admins.includes(String(msg.from.id)) && text.split(' ')[2] != undefined) { //Check if >1 word
            const newFakes = text.substring(text.split(' ')[0].length + 1);
            Data.findOneAndUpdate({name: 'fakeNews'}, {value: newFakes}, function(){});
            bot.sendMessage(msg.chat.id, FakeNewsText + newFakes);
        } else {console.log('not allowed')}
    
    } else if (msg.reply_to_message && msg.reply_to_message.text && msg.reply_to_message.text.indexOf('#comment_') != -1){
        //Process moderator's comment
        const request_id = msg.reply_to_message.text.split('_')[1];
        const commentMsgId = msg.message_id;
        const request = await Request.findByIdAndUpdate(request_id, {commentMsgId: commentMsgId, commentChatId: msg.chat.id });
        informRequestersWithComment(request, msg.chat.id, commentMsgId);

    } else if ((msg.photo || msg.video || (msg.text && msg.text.length > 10)) && !msg.reply_to_message) { //Check if text > 10 in order to sort out short msgs
        console.log(msg);
        //Check any input message 
        const requestId = new mongoose.Types.ObjectId();
        var mediaId, newImage, newVideo;
        var request = new Request({
            _id: requestId,
            requesterTG: msg.chat.id,
            requesterMsgID: msg.message_id,
            requesterUsername: msg.from.username
        });

        if (msg.forward_from_chat) { //Check if message has forwarded data (chat)
            request.telegramForwardedChat = msg.forward_from_chat.id;
            request.telegramForwardedMsg = msg.forward_from_message_id;

            const foundRequest = await Request.findOne({$and: [{telegramForwardedChat: request.telegramForwardedChat}, {telegramForwardedMsg: request.telegramForwardedMsg} ]}, '_id fakeStatus commentChatId commentMsgId');
            if (foundRequest != null) {
                if (foundRequest.fakeStatus == 0) return addToWaitlist(msg, foundRequest);
                return reportStatus(msg, foundRequest);
            }
        } else if (msg.forward_from) { //Check if message has forwarded data
            request.telegramForwardedChat = msg.forward_from.id;
        }
        
        if (msg.photo) { //Check if message has photo data
            mediaId = new mongoose.Types.ObjectId();
            var image = msg.photo.find(obj => { return obj.width === 1280 }) //For now only first photo with 1280*886 resolution
            if (image = []) image = msg.photo[msg.photo.length - 1]; //If there is no 1280 image, let's take the highest possible resolution
            const imageFile = await bot.getFile(image.file_id);
            //const fileUrl = 'https://api.telegram.org/file/bot' + token + '/' + imageFile.file_path;
            
            newImage = new Image({
                _id: mediaId, 
                telegramFileId: image.file_id, 
                telegramUniqueFileId: image.file_unique_id, 
                telegramFilePath: imageFile.file_path,
                fileSize: image.file_size, 
                width: image.width,  
                height: image.height, 
                request: requestId
            });
            request.image = mediaId;

        } else if (msg.video) { //Check if message has video data
            mediaId = new mongoose.Types.ObjectId();
            const video = msg.video;
            newVideo = new Video({
                _id: mediaId, 
                telegramFileId: video.file_id, 
                telegramUniqueFileId: video.file_unique_id,
                fileSize: video.file_size, 
                width: video.width,  
                height: video.height, 
                duration: video.duration,
                request: requestId
            });
            request.video = mediaId;
            
        } else {
            //Check if text is already in DB
            const foundText = await Request.findOne({text: msg.text}, '_id fakeStatus commentChatId commentMsgId');
            if (foundText != null) {
                if (foundText.fakeStatus == 0) return addToWaitlist(msg, foundText);
                return reportStatus(msg, foundText);
            }
        }

        if (msg.text) { //Get text data
            request.text = msg.text;
        } else if (msg.caption) {
            request.text = msg.caption;
        }

        //Save new request in DB
        if (newImage) newImage.save();
        else if (newVideo) newVideo.save(); 
        await request.save(); 

        //Inform user
        bot.sendMessage(msg.chat.id, '–ú–∏ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏ –∞–±–æ –Ω–µ –±–∞—á–∏–ª–∏ —Ç–∞–∫–æ–≥–æ. –ü–æ—á–∞–ª–∏ –æ–ø—Ä–∞—Ü—å–æ–≤—É–≤–∞—Ç–∏ —Ü–µ–π –∑–∞–ø–∏—Ç');
        
        //Send message to moderation
        const sentMsg = await bot.forwardMessage(process.env.TGMAINCHAT, msg.chat.id, msg.message_id);

        var inline_keyboard = [[{ text: '‚õî –§–µ–π–∫', callback_data: 'FS_-1_' + requestId }, { text: 'üü¢ –ü—Ä–∞–≤–¥–∞', callback_data: 'FS_1_' + requestId }]];
        inline_keyboard.push([{ text: '‚úâÔ∏è –ó–∞–ª–∏—à–∏—Ç–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä', callback_data: 'COMMENT_' + requestId }]);
        var options = {
            reply_to_message_id: sentMsg.message_id,
            reply_markup: JSON.stringify({
                inline_keyboard
            }) 
        };
        const sentActionMsg = await bot.sendMessage(process.env.TGMAINCHAT,'#pending',options);
        Request.findByIdAndUpdate(requestId, {moderatorMsgID: sentMsg.message_id, moderatorActionMsgID: sentActionMsg.message_id }, function(){});
    
    } else if (msg.audio || msg.document || msg.voice || msg.location) {
        bot.sendMessage(msg.chat.id, '–ú–∏ –ø–æ–∫–∏ –Ω–µ –æ–±—Ä–æ–±–ª—è—î–º–æ –¥–∞–Ω–∏–π —Ç–∏–ø –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è.\n\n–Ø–∫—â–æ –≤–∏ —Ö–æ—á–µ—Ç–µ –ø–æ–¥—ñ–ª–∏—Ç–∏—Å—å –¥–∞–Ω–æ—é —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—î—é, –Ω–∞–¥—ñ—à–ª—ñ—Ç—å –Ω–∞ –ø–æ—à—Ç—É hello@gwaramedia.com –∑ —Ç–µ–º–æ—é –Ü–ù–§–û–ì–†–ò–ó_–¢–µ–º–∞_–ö–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ —â–æ –º–æ–≤–∞. \n\n–î–æ–¥–∞–π—Ç–µ —è–∫–æ–º–æ–≥–∞ –±—ñ–ª—å—à–µ —Å—É–ø—Ä–æ–≤–æ–¥–∂—É—é—á–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó:\n- –¥–∞—Ç–∞ –º–∞—Ç–µ—Ä—ñ–∞–ª—ñ–≤\n- –ª–æ–∫–∞—Ü—ñ—è\n- —á–æ–º—É —Ü–µ –≤–∞–∂–ª–∏–≤–æ\n- –¥–ª—è –∫–æ–≥–æ —Ü–µ\n\n–Ø–∫—â–æ —Ü–µ –≤–∞–∂–∫—ñ —Ñ–∞–π–ª–∏, –∫—Ä–∞—â–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —ó—Ö –≤ –∫–ª–∞—É–¥ –∑ –ø–æ—Å—Ç—ñ–π–Ω–∏–º –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è–º —ñ –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–∞–º –ø–æ—Å–∏–ª–∞–Ω–Ω—è.');
    }
  
});

bot.on('callback_query', async function onCallbackQuery(callbackQuery) {

    const action = callbackQuery.data;
    const msg = callbackQuery.message;

    if (action.indexOf('FS_') == 0) {
        const requestId = action.split('_')[2], fakeStatus = action.split('_')[1];
        Request.findByIdAndUpdate(requestId, {fakeStatus: fakeStatus}, function(err, request){
            if (!request) return console.log('No request ' + requestId);
            var inline_keyboard = [[{ text: '‚óÄÔ∏è –ó–º—ñ–Ω–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å', callback_data: 'CS_' + requestId }]];
            if (!request.commentChatId) inline_keyboard.push([{ text: '‚úâÔ∏è –ó–∞–ª–∏—à–∏—Ç–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä', callback_data: 'COMMENT_' + requestId }]);
            var status;
            if (fakeStatus == 1) status = "#true | –ü—Ä–∞–≤–¥–∞"
            else if (fakeStatus == -1) status = "#false | –§–µ–π–∫"

            bot.editMessageText("#resolved | " + status, {
                chat_id: msg.chat.id,
                message_id: msg.message_id,
                reply_markup: JSON.stringify({
                    inline_keyboard
                })
            });

            notifyUsers(request, fakeStatus);
                
        });

    } else if (action.indexOf('CS_') == 0) {
        //Change status back to pending
        const requestId = action.split('_')[1];
        const request = await Request.findByIdAndUpdate(requestId, {fakeStatus: 0});
        if (!request) return console.log('No request ' + requestId);
        var inline_keyboard = [[{ text: '‚õî –§–µ–π–∫', callback_data: 'FS_-1_' + requestId }, { text: 'üü¢ –ü—Ä–∞–≤–¥–∞', callback_data: 'FS_1_' + requestId }]];
        if (!request.commentChatId) inline_keyboard.push([{ text: '‚úâÔ∏è –ó–∞–ª–∏—à–∏—Ç–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä', callback_data: 'COMMENT_' + requestId }]);
        
        try {
            bot.editMessageText("#pending", {
                chat_id: msg.chat.id,
                message_id: msg.message_id,
                reply_markup: JSON.stringify({
                    inline_keyboard
                })
            });
        } catch (e){ console.log(e) }
    
    } else if (action.indexOf('COMMENT_') == 0) {
        const requestId = action.split('_')[1];
        const moderator = callbackQuery.from.id;
        const request = await Request.findById(requestId);
        //Send message to moderator (forwarded + action)
        try {
            var sentMsg = await bot.forwardMessage(moderator, msg.chat.id, request.moderatorMsgID);
            var options = {
                reply_to_message_id: sentMsg.message_id,
                reply_markup: JSON.stringify({
                    force_reply: true
                })
            };
        } catch (e){
            bot.sendMessage(msg.chat.id, '–ù–µ–æ–±—Ö—ñ–¥–Ω–æ —Å—Ç–∞—Ä—Ç–∞–Ω—É—Ç–∏ –±–æ—Ç–∞ @perevir_bot\n@' + callbackQuery.from.username + '\n\n' + "FYI @betabitter43");
        }
        
        try {
            bot.sendMessage(moderator, '#comment_' + requestId , options);
        } catch (e){ console.log(e) }
        //Update moderators action message
        var inline_keyboard;
        if (request.fakeStatus == 0) {
            inline_keyboard = [[{ text: '‚õî –§–µ–π–∫', callback_data: 'FS_-1_' + requestId }, { text: 'üü¢ –ü—Ä–∞–≤–¥–∞', callback_data: 'FS_1_' + requestId }]];
        } else {
            inline_keyboard = [[{ text: '‚óÄÔ∏è –ó–º—ñ–Ω–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å', callback_data: 'CS_' + requestId }]];
        }
        bot.editMessageReplyMarkup({
            inline_keyboard: inline_keyboard
        }, {
                chat_id: msg.chat.id,
                message_id: msg.message_id
            });
        //Set moderator for the comment
        Request.findByIdAndUpdate(requestId, {commentChatId: msg.chat.id }, function(){});

    } else if (action.indexOf('SUB_') == 0) {
        //Change status back to pending
        const status = Boolean(parseInt(action.split('_')[1]));
        const userId = action.split('_')[2];
        //Update DB
        const user = await TelegramUser.findByIdAndUpdate(userId, {subscribed: status});
        //Update MSG
        const inline_keyboard = getSubscriptionBtn(status, user._id);
        bot.editMessageReplyMarkup({
            inline_keyboard: inline_keyboard
        }, {
                chat_id: msg.chat.id,
                message_id: msg.message_id
            });

    }
});

function addToWaitlist(msg, foundRequest) {
    try {
        bot.sendMessage(msg.chat.id, '–ö–æ–º–∞–Ω–¥–∞ –≤–∂–µ –æ–±—Ä–æ–±–ª—è—î –¥–∞–Ω–∏–π –∑–∞–ø–∏—Ç. –ü–æ–≤—ñ–¥–æ–º–∏–º–æ –ø—Ä–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑–≥–æ–¥–æ–º');
    } catch (e){ console.log(e) }
    Request.findByIdAndUpdate(foundRequest._id, {$push: { "otherUsetsTG": {requesterTG: msg.chat.id, requesterMsgID: msg.message_id }}}, function(){});
}

function getSubscriptionBtn(status, user_id) {
    var inline_keyboard = [];
    if (status) inline_keyboard.push([{ text: 'üî¥ –í—ñ–¥–º–æ–≤–∏—Ç–∏—Å—è –≤—ñ–¥ –ø—ñ–¥–±—ñ—Ä–æ–∫', callback_data: 'SUB_0_' + user_id }]);
    else inline_keyboard.push([{ text: '‚ú® –û—Ç—Ä–∏–º—É–≤–∞—Ç–∏ –ø—ñ–¥–±—ñ—Ä–∫–∏', callback_data: 'SUB_1_' + user_id }]);
    return inline_keyboard;
}

async function reportStatus(msg, foundRequest) {
    try {
        if (foundRequest.fakeStatus == 1) await bot.sendMessage(msg.chat.id, '–¶—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –≤–∏–∑–Ω–∞—á–µ–Ω–∞ —è–∫ –ø—Ä–∞–≤–¥–∏–≤–∞');
        else if (foundRequest.fakeStatus == -1) await bot.sendMessage(msg.chat.id, '–¶—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –≤–∏–∑–Ω–∞—á–µ–Ω–∞ —è–∫ –æ–º–∞–Ω–ª–∏–≤–∞');
    } catch (e){ console.log(e) } 
    try {
        if (foundRequest.commentMsgId) bot.copyMessage(msg.chat.id, foundRequest.commentChatId, foundRequest.commentMsgId);
    } catch (e){ console.log(e) } 
}

function notifyUsers(foundRequest, fakeStatus) {
    var options = {
        reply_to_message_id: foundRequest.requesterMsgID
    };

    if (fakeStatus == 1) {
        try {
            bot.sendMessage(foundRequest.requesterTG, '–í–∞—à–µ –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è –≤–∏–∑–Ω–∞—á–µ–Ω–æ —è–∫ –ø—Ä–∞–≤–¥–∏–≤–µ', options);
        } catch (e){ console.log(e) }

        for (var i in foundRequest.otherUsetsTG) {
            const optionsR = {
                reply_to_message_id: foundRequest.otherUsetsTG[i].requesterMsgID
            };
            try {
                bot.sendMessage(foundRequest.otherUsetsTG[i].requesterTG, '–í–∞—à–µ –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è –≤–∏–∑–Ω–∞—á–µ–Ω–æ —è–∫ –ø—Ä–∞–≤–¥–∏–≤–µ', optionsR);
            } catch (e){ console.log(e) }
        }

    } else if (fakeStatus == -1) {
        try {
            bot.sendMessage(foundRequest.requesterTG, '–í–∞—à–µ –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è –≤–∏–∑–Ω–∞—á–µ–Ω–æ —è–∫ –æ–º–∞–Ω–ª–∏–≤–µ', options);
        } catch (e){ console.log(e) }

        for (var i in foundRequest.otherUsetsTG) {
            const optionsR = {
                reply_to_message_id: foundRequest.otherUsetsTG[i].requesterMsgID
            };
            try {
                bot.sendMessage(foundRequest.otherUsetsTG[i].requesterTG, '–í–∞—à–µ –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è –≤–∏–∑–Ω–∞—á–µ–Ω–æ —è–∫ –æ–º–∞–Ω–ª–∏–≤–µ', optionsR);
            } catch (e){ console.log(e) }
        }
    }
}

function informRequestersWithComment(request, chatId, commentMsgId) {
    var options = {
        reply_to_message_id: request.requesterMsgID
    };
    
    try {
        bot.copyMessage(request.requesterTG, chatId , commentMsgId, options);
    } catch (e){ console.log(e) }
    
    for (var i in request.otherUsetsTG) {
        const optionsR = {
            reply_to_message_id: request.otherUsetsTG[i].requesterMsgID
        };
        try {
            bot.copyMessage(request.otherUsetsTG[i].requesterTG, chatId , commentMsgId, optionsR);
        } catch (e){ console.log(e) }
    }
    //TASK: Need to handle comment sending for users who joined waiting after comment was send & before fakeStatus changed
}

bot.on("polling_error", (err) => console.log(err.message));

module.exports = {
    message: async function (msg, pin) {
        try {
            const sentMsg = await bot.sendMessage(process.env.TGMAINCHAT, msg);
            if(pin) bot.pinChatMessage(process.env.TGMAINCHAT, sentMsg.message_id);
        } catch (e){ console.log(e) }
    }
};
